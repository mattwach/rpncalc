#!/usr/bin/python
# RPN calculator that supports time based maths and other goodies
#
# By: Matt Wachowski

import atexit
import cmath
import copy
import datetime
import math
import os
import re
import readline
import sys
import time

import calcdocs
import conversion

class Error(Exception):
  pass

class UnknownArgumentError(Error):
  pass

class NoUndoHistoryError(Error):
  pass

class NoRedoHistoryError(Error):
  pass

class ClipboardEmptyError(Error):
  pass

class MacroNotFoundError(Error):
  pass

class FixedModeValueOutOfRangeError(Error):
  pass

class DegreeModeNotSupportedError(Error):
  pass

class InvalidPolarFormatError(Error):
  pass

#
# Builtin vars
#

BUILTIN_VARS = {
    'pi': math.pi,
    'e': math.e,
    'c': 299792458.0, # speed of light
}

#
# RPNCalc Class
#

class RPNCalc(object):

  def __init__(self):
    self.stack = []
    self.undo_history = []
    self.redo_history = []
    self.batch_display = False
    self.display_mode = RPNCalc._NormalMode
    self.manual_mode = False
    self.display_mode_str = None
    self.clipboard = None
    self.stack_clipboard = None
    self.mixed_mode = False
    self.fixed_places = 0
    self.imagj = False
    self.var_dict = copy.copy(BUILTIN_VARS)
    self.degree_mode = False
    self.debug_mode = False
    self.debug_indent = 0
    self.conversion = conversion.Conversion()
    self.macros = {}
    self.line_buffer = []
    self.last_command = ''
    self.reraise = False

  def MakePrompt(self):
    if self.line_buffer:
      prompt = ['... ']
    else:
      prompt = [' ']
      if self.display_mode_str:
        prompt.append(self.display_mode_str)
      if self.mixed_mode:
        prompt.append('mix')
      if self.degree_mode:
        prompt.append('deg')
      if self.debug_mode:
        prompt.append('debug')
      if self.manual_mode:
        prompt.append('manual')
      if self.batch_display:
        prompt.append('batch')
      prompt.append('> ')
    return '|'.join(prompt)

  def ParseLine(self, sub_line, interactive):

    if interactive and (not sub_line) and (not self.line_buffer):
      sub_line = self.last_command

    if '#' in sub_line:
      sub_line = sub_line.split('#')[0]
    sub_line = sub_line.replace(',', '').strip()

    if sub_line.endswith('\\'):
      self.line_buffer.append(sub_line[:-1])
      return False
    else:
      self.line_buffer.append(sub_line)
      line = ' '.join(self.line_buffer)
      if interactive:
        self.last_command = line
      self.line_buffer = []

      if line.startswith('m:'):
        command_list = [line]
      else:
        command_list = line.split()

      return self.ExecCommands(command_list)

  def ExecCommands(self, command_list):
    autodump_stack = False
    def maybe_reraise(e):
      if self.reraise:
        raise e

    try:
      for atom in command_list:
        if self.debug_mode and autodump_stack:
          self.DumpState()
        if self.Parse(atom):
          autodump_stack = True
        if atom == '.' or atom == '..':
          autodump_stack = False
        self._DebugMessage('Exec: %s' % atom)
      if self.debug_mode:
        sys.stdout.write('\n')
    except Error as e:
      self.DumpError(str(e), atom)
      maybe_reraise(e)
    except IndexError as e:
      self.DumpError('Not Enough Stack Arguments', atom)
      maybe_reraise(e)
    except ZeroDivisionError as e:
      self.DumpError('Divide By Zero', None)
      maybe_reraise(e)
    except ValueError as e:
      self.DumpError('Value Error: %s' % e, None)
      maybe_reraise(e)
    except OverflowError as e:
      self.DumpError('Overflow Error: %s' % e, atom)
      maybe_reraise(e)
    except TypeError as e:
      self.DumpError('TypeError: %s' % e, atom)
      maybe_reraise(e)
    except KeyError as e:
      self.DumpError('KeyError', atom)
      maybe_reraise(e)
    except IOError as e:
      self.DumpError('IOError: %s' % e, None)
      maybe_reraise(e)
    except conversion.IllegalConversionBetweenRatioAndScalar as e:
      self.DumpError("Can't convert between a ratio and scalar", atom)
      maybe_reraise(e)
    except conversion.UnknownConversionType as e:
      self.DumpError('Unknown Conversion Type: %s' % e, atom)
      maybe_reraise(e)
    except conversion.IncompatibleConversionTypes as e:
      self.DumpError('Incompatible Conversion Types: %s' % e, atom)
      maybe_reraise(e)

    return autodump_stack

  def Parse(self, arg):
    stack_changed = False

    if arg != 'u' and arg != 'r':
      self.redo_history = []

    for match, callback, _, _ in MATCH_TABLE:
      if isinstance(match, str):
        if match == arg:
          break
      elif match[1].match(arg):
        break
    else:
      callback = None

    if callback:
      stack_changed = callback(self, arg)
    else:
      raise UnknownArgumentError('Unknown Argument (try ? for help)')

    if stack_changed and self.stack:
      if isinstance(self.stack[-1], complex):
        if self.stack[-1].imag == 0:
          # Implicit conversion back to a pure real
          self.stack[-1] = self.stack[-1].real
      elif not self.mixed_mode and not isinstance(self.stack[-1], float):
        self.stack[-1] = float(self.stack[-1])

    return stack_changed

  def DumpError(self, msg, atom):

    sys.stderr.write('\n')
    if atom:
      sys.stderr.write('While parsing %s:\n  ' % atom)
    sys.stderr.write(msg)
    sys.stderr.write('\n!!\n')
    sys.stderr.flush()

  def DumpState(self, _=None):

    try:
      if self.batch_display:
        if self.stack:
          self.DumpVar(None, self.stack[-1])
      else:
        prefix = '  ' * self.debug_indent

        sys.stdout.write('\n')
        if len(self.stack) > 2:
          sys.stdout.write(prefix)
        if len(self.stack) > MAX_STACK_ARGS:
          sys.stdout.write('...  ')

        if len(self.stack) > 2:
          str_args = [
              RPNCalc._NormalMode(self, x)
              for x in self.stack[-MAX_STACK_ARGS:-2]]
          sys.stdout.write('  '.join(str_args))
          sys.stdout.write('\n')

        if len(self.stack) >= 2:
          self.DumpVar('x', self.stack[-2])

        if len(self.stack) >= 1:
          self.DumpVar('y', self.stack[-1])
    except TypeError as e:
      sys.stdout.write('\nTypeError: %s\n' % e)

  def DumpStateLong(self, _=None):
    try:
      sys.stdout.write('\n')
      for index, var in enumerate(self.stack):
        self.DumpVar('s%d' % (len(self.stack) - index), var)
    except TypeError as e:
      sys.stdout.write('\nTypeError: %s\n' % e)

  def DumpVar(self, label, value):

    if not label:
      sys.stdout.write('%s' % self.display_mode(self, value))
    else:
      prefix = '  ' * self.debug_indent
      sys.stdout.write('%s%s = %-15s' % (
          prefix, label, RPNCalc._NormalMode(self, value)))
      if self.display_mode != RPNCalc._NormalMode:
        sys.stdout.write(' | %s' % self.display_mode(self, value))

    sys.stdout.write('\n')

  def Snapshot(self):
    self.undo_history.append(copy.copy(self.stack))
    while len(self.undo_history) > MAX_UNDO_STEPS:
      del self.undo_history[0]

  def DumpVars(self, _):

    for name in sorted(self.var_dict):
      sys.stdout.write('%-15s =  %s\n' % (name, self.var_dict[name]))

    return False

  #
  # Undo / Redo
  #

  def Undo(self, _):
    if len(self.undo_history) < 2:
      raise NoUndoHistoryError('No Undo History Available')
    self.redo_history.append(self.undo_history.pop())
    self.stack = self.undo_history.pop()
    return True

  def Redo(self, _):
    if not self.redo_history:
      raise NoRedoHistoryError('No Redo History Available')
    self.stack = self.redo_history.pop()
    return True

  #
  # Display modes
  #

  def BatchMode(self, _=None):
    self.batch_display = True
    return False

  def InteractiveMode(self, _=None):
    self.batch_display = False
    return False

  def HexMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._HexMode
      self.display_mode_str = 'hex'
      self.mixed_mode = True
    return True

  def PolarMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._PolarMode
      self.display_mode_str = 'polar'
    return True

  def FixedPolarMode(self, arg):
    if arg or not self.manual_mode:
      self._SetFixedMode(int(self.stack.pop()), True)
      self.display_mode = RPNCalc._FixedPolarMode
      self.display_mode_str = 'fixedpolar%d' % self.fixed_places
    return True

  def BinaryMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._BinMode
      self.display_mode_str = 'bin'
      self.mixed_mode = True
    return True

  def DurationMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._DurationMode
      self.display_mode_str = 'dur'
    return True

  def TimeMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._TimeMode
      self.display_mode_str = 'time'
    return True

  def MoneyMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._MoneyMode
      self.display_mode_str = '$'
    return True

  def DateMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._DateMode
      self.display_mode_str = 'date'
    return True

  def CentMode(self, arg):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._CentMode
      self.display_mode_str = 'cent'
    return True

  def FixedMode(self, arg):
    if arg or not self.manual_mode:
      self._SetFixedMode(int(self.stack.pop()), True)
    return True

  def _SetFixedMode(self, amount, force):
    if force:
      if amount < 0 or amount > 20:
        raise FixedModeValueOutOfRangeError(
            'Fixed Mode: value out of range: %d' % amount)
      self.display_mode = RPNCalc._FixedMode
      self.fixed_places = amount
      self.display_mode_str = 'fixed%d' % amount

  def NormalMode(self, arg=None):
    if arg or not self.manual_mode:
      self.display_mode = RPNCalc._NormalMode
      self.display_mode_str = None
    return True

  def DegreeMode(self, _):
    self.degree_mode = True
    return self.display_mode in (RPNCalc._PolarMode, RPNCalc._FixedPolarMode)

  def RadianMode(self, _):
    self.degree_mode = False
    return self.display_mode in (RPNCalc._PolarMode, RPNCalc._FixedPolarMode)

  def DebugMode(self, _):
    self.debug_mode = True
    return False

  def NoDebugMode(self, _):
    self.debug_mode = False
    return False

  def MixedMode(self, _):
    self.mixed_mode = True
    return False

  def FloatMode(self, _):
    self.mixed_mode = False
    return False

  def ManualMode(self, _):
    self.manual_mode = True
    return False

  def AutoMode(self, _):
    self.manual_mode = False
    return False

  def PushFloat(self, arg):
    self.stack.append(float(arg))
    return True

  def PushComplex(self, arg):
    self.imagj = arg[-1] == 'j'
    arg = arg[:-1]  # remove the i or j
    if not arg or arg[-1] == '-' or arg[-1] == '+':
      arg += '1'  # no number was provided for i, add a one to simplify parsing

    # e- complicates the splits below, so take it out, then put it back in later
    arg = arg.replace('e-', 'N')

    if '+' in arg:
      real, imag = arg.split('+')
      if not real:
        real = '0'
    else:
      neg_args = arg.split('-')
      if len(neg_args) == 1:
        real = '0'
        imag = arg
      elif len(neg_args) == 2:
        real, imag = neg_args
        if not real:
          real = '0'
        imag = '-' + imag
      else:
        _, real, imag = arg.split('-')
        real = '-' + real
        imag = '-' + imag

    real = real.replace('N', 'e-')
    imag = imag.replace('N', 'e-')

    self.stack.append(complex(float(real), float(imag)))
    return True

  def PushComplexPolar(self, arg):
    mag, angle = arg.split('<')
    if not mag or not angle:
      raise InvalidPolarFormatError('Invalid Polar Format')
    return self.PushPolarCommon(float(mag), float(angle))

  def PushComplexPolarPhaseOnStack(self, arg):
    angle = self.stack.pop()
    if isinstance(angle, complex):
      raise InvalidPolarFormatError('Phase can not be a complex number')
    mag = arg[:-1]
    return self.PushPolarCommon(float(mag), float(angle))

  def PushPolarCommon(self, mag, angle):
    if self.degree_mode:
      angle = math.radians(angle)

    self.stack.append(complex(mag * math.cos(angle), mag * math.sin(angle)))
    if self.display_mode != RPNCalc._FixedPolarMode:
      self.PolarMode(None)
    return True

  def PushInt(self, arg):
    self.stack.append(int(arg))
    return True


  def PushDurationDays(self, arg):
    if arg.startswith('-'):
      sign = -1
      arg = arg[1:]
    else:
      sign = 1

    d = arg[:-1]
    self.stack.append(sign * int(d) * 86400)
    self._CheckDurationMode()
    return True

  def PushDurationDHMS(self, arg):
    if arg.startswith('-'):
      sign = -1
      arg = arg[1:]
    else:
      sign = 1
    d, hms = arg.split('d')
    h, m, s = hms.split(':')
    self.stack.append(sign * (int(d) * 86400 +
                              int(h) * 3600 +
                              int(m) * 60 +
                              int(s)))
    self._CheckDurationMode()
    return True

  def PushDurationHMS(self, arg):
    if arg.startswith('-'):
      sign = -1
      arg = arg[1:]
    else:
      sign = 1
    h, m, s = arg.split(':')
    self.stack.append(sign * (int(h) * 3600 + int(m) * 60 + int(s)))
    self._CheckDurationMode()
    return True

  def PushDurationMS(self, arg):
    if arg.startswith('-'):
      sign = -1
      arg = arg[1:]
    else:
      sign = 1
    m, s = arg.split(':')
    self.stack.append(sign * (int(m) * 60 + int(s)))
    self._CheckDurationMode()
    return True

  def PushCurrentTime(self, _):
    self.stack.append(time.time())
    self._CheckTimeMode()
    return True

  def PushToday(self, _):
    today = time.mktime(datetime.date.today().timetuple())
    self.stack.append(today)
    self._CheckTimeMode()
    return True

  def PushDateThisYear(self, arg):
    month, day = arg.split('/')
    today = datetime.date.today()
    the_date = today.replace(month=int(month), day=int(day))
    self.stack.append(time.mktime(the_date.timetuple()))
    self._CheckTimeMode()
    return True

  def PushDate(self, arg):
    month, day, year = arg.split('/')
    today = datetime.date.today()
    the_date = today.replace(month=int(month), day=int(day), year=int(year))
    self.stack.append(time.mktime(the_date.timetuple()))
    self._CheckTimeMode()
    return True

  def PushDateTime(self, arg):
    date, time_str = arg.split('+')
    month, day, year = date.split('/')
    hour, minute, second = time_str.split(':')
    now = datetime.datetime.now()
    the_date = now.replace(month=int(month), day=int(day), year=int(year),
                           hour=int(hour), minute=int(minute),
                           second=int(second))
    self.stack.append(time.mktime(the_date.timetuple()))
    self._CheckTimeMode()
    return True

  def PushHex(self, arg):
    self.HexMode(None)
    self.stack.append(int(arg, 16))
    return True

  def PushBin(self, arg):
    self.BinaryMode(None)
    if arg[0] == '-':
      self.stack.append(-int(arg[3:], 2))
    else:
      self.stack.append(int(arg[2:], 2))
    return True

  def Add(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(x + y)
    return True

  def Subtract(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(x - y)
    return True

  def Multiply(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(x * y)
    return True

  def PowerOf(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(x ** y)
    return True

  def Divide(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(x / y)
    return True

  def Mod(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(x % y)
    return True

  def Factorial(self, _):
    y = self.stack.pop()
    self.stack.append(math.factorial(y))
    return True

  def Inverse(self, _):
    y = float(self.stack.pop())
    self.stack.append(1.0 / y)
    return True

  def Negate(self, _):
    y = self.stack.pop()
    self.stack.append(-y)
    return True

  def AbsoluteValue(self, _):
    y = self.stack.pop()
    if y < 0:
      y = -y
    self.stack.append(y)
    return True

  def LogicalAnd(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(int(x) & int(y))
    self.HexMode(None)
    return True

  def LogicalOr(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(int(x) | int(y))
    self.HexMode(None)
    return True

  def LogicalXOR(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(int(x) ^ int(y))
    self.HexMode(None)
    return True

  def LogicalShiftRight(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(int(x) >> int(y))
    self.HexMode(None)
    return True

  def LogicalShiftLeft(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(int(x) << int(y))
    self.HexMode(None)
    return True

  def Swap(self, _):
    y = self.stack.pop()
    x = self.stack.pop()
    self.stack.append(y)
    self.stack.append(x)
    return True

  def RollDown(self, _):
    y = self.stack.pop()
    self.stack.insert(0, y)
    return True

  def RollUp(self, _):
    y = self.stack.pop(0)
    self.stack.append(y)
    return True

  def Duplicate(self, _):
    self.stack.append(self.stack[-1])
    return True

  def Drop(self, _):
    self.stack.pop()
    return True

  def Clear(self, _):
    self.stack = []
    return True

  def Reverse(self, _):
    self.stack.reverse()
    return True

  def Type(self, _):
    y = self.stack.pop()
    if isinstance(y, int):
      self.stack.append(float(y))
    else:
      self.mixed_mode = True
      self.stack.append(int(y))
    return True

  #
  # Clipboard operations
  #

  def Cut(self, _):
    self.clipboard = self.stack.pop()
    return True

  def Copy(self, _):
    self.clipboard = self.stack[-1]
    return False

  def Paste(self, _):
    if self.clipboard is None:
      raise ClipboardEmptyError('Clipboard is empty')
    self.stack.append(self.clipboard)
    return True

  def PositionalCut(self, arg):
    return self.PositionalCopy(arg, True)

  def PositionalCopy(self, _, cut=False):
    pos = int(self.stack.pop())
    if pos < 0:
      raise IndexError()
    self.clipboard = self.stack[-(pos + 1)]
    if cut:
      del self.stack[-(pos + 1)]
    return True

  def PositionalPaste(self, _):
    if self.clipboard is None:
      raise ClipboardEmptyError('Clipboard is empty')
    pos = int(self.stack.pop())
    if pos < 0:
      raise IndexError()
    self.stack.insert(-pos, self.clipboard)
    return True

  def CutStack(self, _):
    self.stack_clipboard = self.stack
    self.stack = []
    return True

  def CopyStack(self, _):
    self.stack_clipboard = copy.copy(self.stack)
    return False

  def PasteStack(self, _):
    self.stack = copy.copy(self.stack_clipboard)
    return True

  def CopyVar(self, arg):
    var_name = arg.split(':')[1]
    self.var_dict[var_name] = self.stack[-1]
    return False

  def CutVar(self, arg):
    var_name = arg.split(':')[1]
    self.var_dict[var_name] = self.stack.pop()
    return True

  def PasteVar(self, arg):
    var_name = arg.split(':')[1]
    self.stack.append(self.var_dict[var_name])
    return True

  #
  # Statistics
  #

  def Sum(self, _):
    list_sum = sum(self.stack)
    self.stack = [list_sum]
    return True

  def Mean(self, _):
    list_sum = float(sum(self.stack))
    self.stack = [list_sum / len(self.stack)]
    return True

  def Median(self, _):
    self.stack.sort()
    self.stack = [self.stack[len(self.stack) / 2]]
    return True

  def Log(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self.stack.append(cmath.log(y))
    else:
      self.stack.append(math.log(float(y)))
    return True

  def Log10(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self.stack.append(cmath.log10(y))
    else:
      self.stack.append(math.log10(float(y)))
    return True

  def Square(self, _):
    y = self.stack.pop()
    self.stack.append(y * y)
    return True

  def SquareRoot(self, _):
    y = self.stack.pop()
    if isinstance(y, complex) or y < 0:
      self.stack.append(cmath.sqrt(y))
    else:
      self.stack.append(math.sqrt(y))
    return True

  def _PopTrig(self):
    y = self.stack.pop()
    if self.degree_mode:
      if isinstance(y, complex):
        raise DegreeModeNotSupportedError(
            'Degree mode is not supported for complex trigonometry')
      y = math.radians(y)
    return y

  def _PushTrig(self, y):
    if self.degree_mode:
      if isinstance(y, complex):
        raise DegreeModeNotSupportedError(
            'Degree mode is not supported for complex trigonometry')
      y = math.degrees(y)
    self.stack.append(y)

  def Sin(self, _):
    y = self._PopTrig()
    if isinstance(y, complex):
      self.stack.append(cmath.sin(y))
    else:
      self.stack.append(math.sin(y))
    return True

  def Cos(self, _):
    y = self._PopTrig()
    if isinstance(y, complex):
      self.stack.append(cmath.cos(y))
    else:
      self.stack.append(math.cos(y))
    return True

  def Tan(self, _):
    y = self._PopTrig()
    if isinstance(y, complex):
      self.stack.append(cmath.tan(y))
    else:
      self.stack.append(math.tan(y))
    return True

  def ASin(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self._PushTrig(cmath.asin(y))
    else:
      self._PushTrig(math.asin(y))
    return True

  def ACos(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self._PushTrig(cmath.acos(y))
    else:
      self._PushTrig(math.acos(y))
    return True

  def ATan(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self._PushTrig(cmath.atan(y))
    else:
      self._PushTrig(math.atan(y))
    return True

  def Convert(self, arg):
    self._SetFixedMode(3, False)
    y = self.stack.pop()
    y_type, target_type = arg.split('>')
    converted = self.conversion.Convert(y, y_type, target_type)
    self.stack.append(converted)
    return True

  def HelpShort(self, arg):
    return self.Help(arg, long_command_list=False)

  def Documentation(self, arg):
    return self.Help(arg, long_command_list=True, docs_mode=True)

  def Help(self, _, long_command_list=True, docs_mode=False):
    if docs_mode:
      sys.stdout.write(calcdocs.DOCS['introduction'])

    sys.stdout.write('\n\n# Detailed Documentation\n')

    class_list = []
    class_map = {}

    for cmd, _, class_str, help_str in MATCH_TABLE:
      if not isinstance(cmd, str):
        cmd = cmd[0]
      if class_str not in class_map:
        class_list.append(class_str)
        class_map[class_str] = []
      if long_command_list:
        class_map[class_str].append('    %-20s  %s\n' % (cmd, help_str))
      else:
        class_map[class_str].append('  %-20s' % cmd)

    for class_str in class_list:
      sys.stdout.write('\n## %s\n' % class_str)

      if docs_mode:
        sys.stdout.write(calcdocs.DOCS[class_str])
        sys.stdout.write('\n### Supported Commands\n\n')

      if not long_command_list:
        sys.stdout.write('  ')
        line_length = 2

      for line in class_map[class_str]:
        if not long_command_list:
          line_length += len(line)
          if line_length > MAX_HELP_LINE_LENGTH:
            sys.stdout.write('\n  ')
            line_length = 2
        sys.stdout.write(line)

    if not docs_mode:
      sys.stdout.write('\n\n')
      sys.stdout.write(calcdocs.DOCS['short'])
      sys.stdout.write('\n\n? for help, ?? for more help, ??? for full docs\n')

    return False

  def HelpConversions(self, _):
    self.conversion.DumpHelp()
    return False

  def Quit(self, _):
    sys.exit(0)

  def DefineMacro(self, arg):

    arg_list = arg.split()
    macro_name = arg_list[0][2:]
    macro_args = arg_list[1:]
    self.macros[macro_name] = macro_args
    self._DebugMessage('Defined macro: %s\n' % macro_name)

    return False

  def ExecuteMacro(self, arg):

    macro_name = arg[1:]
    if macro_name not in self.macros:
      raise MacroNotFoundError('Macro Not Found: %s' % macro_name)

    if self.debug_mode:
      self._DebugMessage('Executing macro: %s %s\n' %
                         (macro_name, ' '.join(self.macros[macro_name])))
      self.debug_indent += 1
    flag = self.ExecCommands(self.macros[macro_name])
    if self.debug_mode:
      self.debug_indent -= 1
    return flag

  def ListMacros(self, _):

    if self.macros:
      for name in sorted(self.macros):
        sys.stdout.write('%-15s |  %s\n' % (name, ' '.join(self.macros[name])))
    else:
      sys.stdout.write('No Macros Defined\n')

    return False

  #
  # Miscellaneous
  #

  def SourceFile(self, arg):
    flag = False
    if self.debug_mode:
      self._DebugMessage('Sourcing File: %s\n' % arg[2:])
      self.debug_indent += 1
    filename = open(arg[2:], 'r')
    for line in filename:
      if self.ParseLine(line, False):
        flag = True
    if self.debug_mode:
      self.debug_indent -= 1
    return flag

  #
  # Conditional Operators
  #

  def ExecuteConditional(self, arg):
    self._DebugMessage('Testing Conditional Macro: %s\n' % arg)
    y = self.stack.pop()
    if y:
      self.ExecuteMacro(arg)
    return True

  def GreaterThan(self, _):
    return self._PushConditional(lambda x, y: x > y)

  def LessThan(self, _):
    return self._PushConditional(lambda x, y: x < y)

  def GreaterThanEqual(self, _):
    return self._PushConditional(lambda x, y: x >= y)

  def LessThanEqual(self, _):
    return self._PushConditional(lambda x, y: x <= y)

  def Equal(self, _):
    return self._PushConditional(lambda x, y: x == y)

  def NotEqual(self, _):
    return self._PushConditional(lambda x, y: x != y)

  def Not(self, _):
    y = self.stack.pop()
    if y:
      self.stack.append(0)
    else:
      self.stack.append(1)
    return True

  def Real(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self.stack.append(y.real)
    else:
      self.stack.append(y)
    return True

  def Imag(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self.stack.append(y.imag)
    else:
      self.stack.append(0)
    return True

  def Magnitude(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      self.stack.append(cmath.polar(y)[0])
    else:
      self.stack.append(y)
    return True

  def Phase(self, _):
    y = self.stack.pop()
    if isinstance(y, complex):
      angle = cmath.polar(y)[1]
      if self.degree_mode:
        angle = math.degrees(angle)
      self.stack.append(angle)
    else:
      self.stack.append(0)
    return True

  #
  # Internal Helpers
  #

  def _PushConditional(self, cond):
    y = self.stack.pop()
    x = self.stack.pop()
    if cond(x, y):
      self.stack.append(1)
    else:
      self.stack.append(0)
    return True

  def _CheckDurationMode(self):
    if ((self.display_mode != RPNCalc._TimeMode) and
        (self.display_mode != RPNCalc._DurationMode)):
      self.DurationMode(None)

  def _CheckTimeMode(self):
    if ((self.display_mode != RPNCalc._TimeMode) and
        (self.display_mode != RPNCalc._DateMode)):
      self.TimeMode(None)

  def _DebugMessage(self, msg):
    if self.debug_mode:
      sys.stdout.write('\n')
      sys.stdout.write('  ' * self.debug_indent)
      sys.stdout.write(msg)

  #
  # Display Mode Callbacks
  #
  @staticmethod
  def _NormalMode(this, value):
    if isinstance(value, complex):
      letter = 'j' if this.imagj else 'i'
      if value.real == 0:
        return '%s%s' % (value.imag, letter)

      return '%s%s%s%s' % (
          value.real,
          '+' if value.imag >= 0 else '',
          value.imag,
          letter
      )
    return str(value)

  @staticmethod
  def _FixedMode(this, value):
    if isinstance(value, complex):
      letter = 'j' if this.imagj else 'i'
      if value.real == 0:
        format_str = '%.{fp}f{letter}'.format(
            fp=this.fixed_places,
            letter=letter
        )
        return format_str % value.imag

      format_str = '%.{fp}f{sign}%.{fp}f{letter}'.format(
          fp=this.fixed_places,
          sign='+' if value.imag >= 0 else '',
          letter=letter
      )
      return format_str % (value.real, value.imag)

    format_str = '%.{fp}f'.format(fp=this.fixed_places)
    return format_str % value

  @staticmethod
  def _HexMode(_, value):
    if isinstance(value, complex):
      value = value.real

    if value >= 0:
      ret = '%X' % value
    else:
      ret = '%X' % (0-value)

    if len(ret) & 1:
      ret = '0' + ret

    if value < 0:
      return '-0x' + ret

    return '0x' + ret

  @staticmethod
  def _PolarMode(this, value):
    if not isinstance(value, complex):
      return str(value)

    mag, phase = cmath.polar(value)
    if this.degree_mode:
      phase = math.degrees(phase)

    return '%s<%s' % (mag, phase)

  @staticmethod
  def _FixedPolarMode(this, value):
    if not isinstance(value, complex):
      return RPNCalc._FixedMode(this, value)

    mag, phase = cmath.polar(value)
    if this.degree_mode:
      phase = math.degrees(phase)

    return '%s<%s' % (
        RPNCalc._FixedMode(this, mag),
        RPNCalc._FixedMode(this, phase))

  @staticmethod
  def _BinMode(_, value):
    if isinstance(value, complex):
      value = value.real
    return bin(int(value))

  @staticmethod
  def _DateMode(_, value):
    if isinstance(value, complex):
      value = value.real

    ret = ''

    if value > 0:
      t = time.localtime(value)
      if ((t.tm_hour == 0) and
          (t.tm_min == 0) and
          (t.tm_sec == 0)):
        ret = time.strftime('%m/%d/%Y (%a)', t)
      else:
        ret = time.strftime('%m/%d/%Y+%H:%M:%S (%a)', t)

    return ret

  @staticmethod
  def _TimeMode(this, value):
    if isinstance(value, complex):
      value = value.real
    if value > 31536000:
      return RPNCalc._DateMode(this, value)
    return RPNCalc._DurationMode(this, value)

  @staticmethod
  def _DurationMode(_, value):
    if isinstance(value, complex):
      value = value.real
    ret = ''
    sign = ' '
    if value < 0:
      sign = '-'
      value = -value

    iv = int(value)
    d = iv / 86400
    h = (iv / 3600) % 24
    m = (iv / 60) % 60
    s = iv % 60
    if d > 0:
      if h == 0 and m == 0 and s == 0:
        ret = '  %s%dd' % (sign, d)
      else:
        ret = '  %s%dd%02d:%02d:%02d' % (sign, d, h, m, s)
    elif h > 0:
      ret = '  %s%02d:%02d:%02d' % (sign, h, m, s)
    else:
      ret = '     %s%02d:%02d' % (sign, m, s)

    return ret

  @staticmethod
  def _MoneyMode(_, value):
    if isinstance(value, complex):
      value = value.real
    if value < 0:
      ret = '-$'
      value = -value
    else:
      ret = ' $'
    return (ret + '%.0f.%02d' %
            (math.floor(value), int((value + 0.005 - math.floor(value)) * 100)))

  @staticmethod
  def _CentMode(this, value):
    if isinstance(value, complex):
      value = value.real
    return RPNCalc._MoneyMode(this, value / 100.0)

# Match up inputs with regular expressions
#
# The idea is to cleanly find the correct funtion to call for a given input

CB = 'Clipboard'
DB = 'Expression Debugging'
EX = 'Exiting'
LO = 'Logical Operators'
MA = 'Macros and Conditionals'
MO = 'Display Modes'
MS = 'Misc'
NM = 'Numbers'
OP = 'Operators'
SC = 'Scientific'
SM = 'Stack Management'
ST = 'Statistics'
TR = 'Trigonometry'
TY = 'Type Conversion'
UR = 'Undo/Redo'
CM = 'Complex Numbers'

INT = '-?[0-9]+'
FLOAT = r'-?([0-9]|\.)[0-9]*\.?[0-9]*e?-?[0-9]*'

MATCH_TABLE = [
    ('.', RPNCalc.DumpState, SM, 'Dump Stack (short form)'),
    ('..', RPNCalc.DumpStateLong, SM, 'Dump Full Stack'),
    ('d', RPNCalc.Duplicate, SM, 'Duplicate y'),
    ('y', RPNCalc.Drop, SM, 'Drop y'),
    ('D', RPNCalc.Clear, SM, 'Clear Stack'),
    ('R', RPNCalc.Reverse, SM, 'Reverse Stack'),
    ('s', RPNCalc.Swap, SM, 'Swap x <-> y'),
    ('rd', RPNCalc.RollDown, SM, 'Roll Stack Down'),
    ('ru', RPNCalc.RollUp, SM, 'Roll Stack Up'),

    (('1, -512', re.compile(r'%s$' % INT)),
     RPNCalc.PushInt, NM, 'Integers'),
    (('1.0, 1., .5, 1e6, 2.5e-6', re.compile(r'^%s$' % FLOAT)),
     RPNCalc.PushFloat, NM, 'Floating point numbers'),
    (('i, -2j', re.compile(r'-?(%s)?[ij]$' % FLOAT)),
     RPNCalc.PushComplex, CM, 'Complex number in rectangular form'),
    (('1+5i, 3-2j', re.compile(r'^{fl}\+?({fl})?[ij]$'.format(fl=FLOAT))),
     RPNCalc.PushComplex, CM, 'Complex number in rectangular form'),
    (('0x36, -0x1234', re.compile(r'^-?0x[0-9a-fA-F]+$')),
     RPNCalc.PushHex, NM, 'Hexidecimal numbers'),
    (('1001b, -1001b', re.compile(r'^-?0b[0-1]+$')),
     RPNCalc.PushBin, NM, 'Binary numbers'),
    (('4d, 15d', re.compile(r'^-?[0-9]+d$')),
     RPNCalc.PushDurationDays, NM, 'Time Duration, in days'),
    (('1d14:23:12', re.compile(r'^-?[0-9]+d[0-9]+:[0-5][0-9]:[0-5][0-9]$')),
     RPNCalc.PushDurationDHMS, NM, 'Time Duration, DdHH:MM:SS'),
    (('534:12:00', re.compile(r'^-?[0-9]+:[0-5][0-9]:[0-5][0-9]$')),
     RPNCalc.PushDurationHMS, NM, 'Time Duration H:MM:SS'),
    (('536:45', re.compile(r'^-?[0-9]+:[0-5][0-9]$')),
     RPNCalc.PushDurationMS, NM, 'Time Duration M:SS'),
    (('01/14, 2/12', re.compile(r'^[01]?[0-9]/[0-3]?[0-9]$')),
     RPNCalc.PushDateThisYear, NM, 'Date (this year)'),
    (('01/14/2010, 2/12/1990', re.compile(r'^[01]?[0-9]/[0-3]?[0-9]/[0-9]+$')),
     RPNCalc.PushDate, NM, 'Date'),
    (('07/30/2006+16:00:00',
      re.compile(
          r'^[01]?[0-9]/[0-3]?[0-9]/[0-9]+\+[01]?[0-9]:'
          '[0-5][0-9]:[0-5][0-9]$')),
     RPNCalc.PushDateTime, NM, 'Date'),
    ('now', RPNCalc.PushCurrentTime, NM, 'Current time and date'),
    ('today', RPNCalc.PushToday, NM, 'Current date'),
    ('mixed', RPNCalc.MixedMode, NM, 'Allow integers and floats'),
    ('floats', RPNCalc.FloatMode, NM, 'Convert everything to floats (Default)'),
    ('t', RPNCalc.Type, NM, 'Convert float to int (and visa versa)'),

    ('*', RPNCalc.Multiply, OP, 'x * y'),
    ('+', RPNCalc.Add, OP, 'x + y'),
    ('-', RPNCalc.Subtract, OP, 'x - y'),
    ('/', RPNCalc.Divide, OP, 'x / y'),

    ('&', RPNCalc.LogicalAnd, LO, 'x & y (Logical And)'),
    ('|', RPNCalc.LogicalOr, LO, 'x | y (Logical Or)'),
    ('^', RPNCalc.LogicalXOR, LO, 'x ^ y (Logical XOR)'),
    ('>>', RPNCalc.LogicalShiftRight, LO, 'x >> y (Logical Shift Right)'),
    ('<<', RPNCalc.LogicalShiftLeft, LO, 'x << y (Logical Shift Left)'),

    ('log10', RPNCalc.Log10, SC, 'Log (base 10)'),
    ('log', RPNCalc.Log, SC, 'Log (base e)'),
    ('sq', RPNCalc.Square, SC, 'Square'),
    ('sqrt', RPNCalc.SquareRoot, SC, 'Square Root'),
    ('%', RPNCalc.Mod, SC, 'x % y (Mod)'),
    ('!', RPNCalc.Factorial, SC, 'y! (Factorial)'),
    ('inv', RPNCalc.Inverse, SC, '1.0/y (inverse)'),
    ('neg', RPNCalc.Negate, SC, '-y (negate)'),
    ('abs', RPNCalc.AbsoluteValue, SC, 'abs(y) (absolute value)'),
    ('**', RPNCalc.PowerOf, SC, 'x ** y  (power of)'),

    ('sin', RPNCalc.Sin, TR, 'Sin'),
    ('cos', RPNCalc.Cos, TR, 'Cos'),
    ('tan', RPNCalc.Tan, TR, 'Tan'),
    ('asin', RPNCalc.ASin, TR, 'Arc Sin'),
    ('acos', RPNCalc.ACos, TR, 'Arc Cos'),
    ('atan', RPNCalc.ATan, TR, 'Arc Tan'),
    ('deg', RPNCalc.DegreeMode, TR, 'Use degrees for trig functions'),
    ('rad', RPNCalc.RadianMode, TR, 'Use radians for trig functions (default)'),

    ('c', RPNCalc.Copy, CB, 'Copy y'),
    ('x', RPNCalc.Cut, CB, 'Cut (Pop) y'),
    ('v', RPNCalc.Paste, CB, 'Paste (Push) y'),
    ('pc', RPNCalc.PositionalCopy, CB, 'Copy stack[y], where x is index 0'),
    ('px', RPNCalc.PositionalCut, CB, 'Cut stack[y], where x is index 0'),
    ('pv', RPNCalc.PositionalPaste, CB,
     'Paste (insert) at stack[y], where x is index 0'),
    (('c:<varname>', re.compile(r'^c:[a-zA-Z0-9_]+$')),
     RPNCalc.CopyVar, CB, 'Copy y to varname'),
    (('x:<varname>', re.compile(r'^x:[a-zA-Z0-9_]+$')),
     RPNCalc.CutVar, CB, 'Cut y to varname'),
    (('v:<varname>', re.compile(r'^v:[a-zA-Z0-9_]+$')),
     RPNCalc.PasteVar, CB, 'paste varname to stack'),
    ('l:v', RPNCalc.DumpVars, CB, 'Show all defined variables'),
    ('x', RPNCalc.Cut, CB, 'Cut (Pop) y'),
    ('v', RPNCalc.Paste, CB, 'Paste (Push) y'),
    ('C', RPNCalc.CopyStack, CB, 'Copy stack'),
    ('X', RPNCalc.CutStack, CB, 'Cut stack'),
    ('V', RPNCalc.PasteStack, CB, 'Paste stack'),

    ('r', RPNCalc.Redo, UR, 'Redo last undo (only if it was last command)'),
    ('u', RPNCalc.Undo, UR, 'Undo to last [Enter] state'),

    ('q', RPNCalc.Quit, EX, 'Quit/Exit'),

    (('s:<path>', re.compile(r'^s:.+$')), RPNCalc.SourceFile, MS,
     'Execute commands found in <path>'),
    ('?', RPNCalc.HelpShort, MS, 'Short Help'),
    ('??', RPNCalc.Help, MS, 'Verbose Help'),
    ('???', RPNCalc.Documentation, MS, 'Full Documentation'),

    ('sum', RPNCalc.Sum, ST, 'Sum All Arguments'),
    ('mean', RPNCalc.Mean, ST, 'Mean All Arguments'),
    ('median', RPNCalc.Median, ST, 'Median All Arguments'),

    ('fixed', RPNCalc.FixedMode, MO,
     'Turn on fixed-width mode (y holds sig digits)'),
    ('fixedpolar', RPNCalc.FixedPolarMode, MO,
     'Turn on fixed-width polar mode (y holds sig digits)'),
    ('polar', RPNCalc.PolarMode, MO, 'Turn on polar mode'),
    ('hex', RPNCalc.HexMode, MO, 'Turn on hexadecimal display'),
    ('bin', RPNCalc.BinaryMode, MO, 'Turn on binary display'),
    ('dur', RPNCalc.DurationMode, MO, 'Turn on duration (time) display'),
    ('date', RPNCalc.DateMode, MO, 'Turn on date display'),
    ('time', RPNCalc.TimeMode, MO,
     'Turn on date or duration (auto select) display'),
    ('$', RPNCalc.MoneyMode, MO, 'Turn on Money Display mode'),
    ('cent', RPNCalc.CentMode, MO, 'Turn on Cent-Wise Money Display mode'),
    ('normal', RPNCalc.NormalMode, MO, 'Turn off special display modes'),
    ('batch', RPNCalc.BatchMode, MO, 'Only output formatted results'),
    ('interactive', RPNCalc.InteractiveMode, MO, 'Show interactive stack dump'),
    ('manual', RPNCalc.ManualMode, MO,
     'Do not automatically change display modes'),
    ('auto', RPNCalc.AutoMode, MO,
     'Automatically change display modes based on input syntax (default)'),

    ('debug', RPNCalc.DebugMode, DB,
     'Turn on expression debug (show all stack steps)'),
    ('nodebug', RPNCalc.NoDebugMode, DB, 'Turn off expression debug'),

    (('mph>min/mile, yard*yard>ft*ft',
      re.compile('^[a-z*]+(/[a-z*]+)?>[a-z*]+(/[a-z*]+)?$')),
     RPNCalc.Convert, TY, 'Convert between number types'),
    ('l:c', RPNCalc.HelpConversions, TY, 'Dump all known conversion keys'),

    (('m:<name> x y z...', re.compile('^m:[a-zA-Z_0-9]+ .+$')),
     RPNCalc.DefineMacro, MA, 'Define a macro'),
    (('@<name>', re.compile(r'^@[a-zA-Z_0-9]+$')),
     RPNCalc.ExecuteMacro, MA, 'Execute a defined macro'),
    (('?<name>', re.compile(r'^\?[a-zA-Z_0-9]+$')),
     RPNCalc.ExecuteConditional, MA,
     'Pop y and execute <macro> only if non-zero'),
    ('l:m', RPNCalc.ListMacros, MA, 'List defined macros'),
    ('>', RPNCalc.GreaterThan, MA, '1 if x > y, 0 otherwise'),
    ('<', RPNCalc.LessThan, MA, '1 if x < y, 0 otherwise'),
    ('>=', RPNCalc.GreaterThanEqual, MA, '1 if x >= y, 0 otherwise'),
    ('<=', RPNCalc.LessThanEqual, MA, '1 if x <= y, 0 otherwise'),
    ('==', RPNCalc.Equal, MA, '1 if x == y, 0 otherwise'),
    ('!=', RPNCalc.NotEqual, MA, '1 if x != y, 0 otherwise'),
    ('not', RPNCalc.Not, MA, '1 if y == 0, 0 otherwise'),
    (('1<, -2.6<', re.compile(
        r'^%s<$' % FLOAT)),
     RPNCalc.PushComplexPolarPhaseOnStack, CM,
       'Complex numbers in polar form (pull phase from stack)'),
    (('1<3.14, -2.6<-45.5', re.compile(
        r'{fl}<{fl}$'.format(fl=FLOAT))),
     RPNCalc.PushComplexPolar, CM, 'Complex numbers in polar form'),
    ('real', RPNCalc.Real, CM, 'Extract real part of a complex number'),
    ('imag', RPNCalc.Imag, CM,
     'Extract imaginary part of a complex number'),
    ('mag', RPNCalc.Magnitude, CM, 'Extract magnitude of a complex number'),
    ('phase', RPNCalc.Phase, CM, 'Extract phase angle of a complex number'),
]

MAX_STACK_ARGS = 10
MAX_UNDO_STEPS = 50
MAX_HELP_LINE_LENGTH = 80

# main loop

def main(rpn_calc=None):
  sys.stdout.write('Try ? for help\n')

  histfile = os.path.join(os.path.expanduser("~"), ".rpnhist")
  try:
    readline.read_history_file(histfile)
  except IOError:
    pass
  atexit.register(readline.write_history_file, histfile)

  if rpn_calc is None:
    rpn_calc = RPNCalc()
  stack_changed = False

  while True:

    if stack_changed:
      rpn_calc.DumpState()
      rpn_calc.Snapshot()

    try:
      sys.stdout.flush()
      line = raw_input(rpn_calc.MakePrompt())
    except EOFError:
      sys.stdout.write('\n')
      sys.exit(0)

    stack_changed = rpn_calc.ParseLine(line, True)
    rpn_calc.debug_indent = 0

def batch(args):

  main_continue = False
  if args[-1] == '--':
    main_continue = True
    args = args[:-1]

  rpn_calc = RPNCalc()
  rpn_calc.BatchMode()
  rpn_calc.reraise = True
  rc = 0

  try:
    for arg in args:
      if rpn_calc.ParseLine(arg, False):
        rpn_calc.DumpState()
  except Exception as e:  # pylint: disable=broad-except
    sys.stderr.write('%s\n' % e)
    rc = 1

  if main_continue:
    rpn_calc.InteractiveMode()
    main(rpn_calc)
  sys.exit(rc)


if __name__ == '__main__':
  if len(sys.argv) > 1:
    batch(sys.argv[1:])
  else:
    main()
